Basic Operations on Stack
In order to make manipulations in a stack, there are certain operations provided to us.

push() to insert an element into the stack
pop() to remove an element from the stack
top() Returns the top element of the stack.
isEmpty() returns true is stack is empty else false
size() returns the size of stack

Push:
Adds an item to the stack. If the stack is full, then it is said to be an Overflow condition.
---------
5    [4]  -> top
---------
4 [3]  -> top
---------
3 [2]
---------
2 [1]
---------
1 [0]
---------
Size  :- 5

push(newElement)
begin
	if stack is full -> (Stack size (5) -> all 5 locations have elements, then you are trying to add an element)
		return
	increment top
	stack[top] assign the newElement

Pop:
Removes an item from the stack. The items are popped in the reversed order in which they are pushed. If the stack is empty, then it is said to be an Underflow condition.
---------

---------
4 [3]   -> top
---------
3 [2]
---------
2 [1]
---------
1 [0]
---------
Size  :- 5
pop(){
	if(stack is empty){
		return
	}
	int removedValue = stack[top];
	decrement top; top--
	return removedValue;
}

top(){
	return stack[top]
}


1. Check for Balanced Brackets in an expression (well-formedness) using Stack

Input: exp = “[()]{}{[()()]()}”
Output: Balanced
Explanation: all the brackets are well-formed

Input: exp = “[()}” , "[", "]", "(]", "()(", "[()]"
Output: Not Balanced
Explanation: all the brackets are well-formed





Whenever we encounter an opening bracket, then push the bracket in to the stack

Whenever we encounter an closing bracket,
		then peek and verify is the top bracket is matching opening bracket
			-> pop -> top element in the stack

Input :- ( [ { } ] )

0 -> ( -> Stack -> (
1 -> [ -> Stack -> ( [
2 -> { -> Stack -> ( [ {
3 -> } -> Matching condition -> peek() -> {
				are these matching brackets {  }
				pop -> {  -> Current Stack -> ( [
4 -> ] -> Matching condition -> peek() -> [
				are these matching brackets [ ]
				pop -> [ -> Current Stack -> (
5 -> ) -> Matching condition -> peek() -> (
				are these matching brackets  ( )
				pop ->( -> Current Stack

Stack -> Empty =>  So brackets are balanced.

[()}

0 -> [  -> Stack -> [
1 -> (  -> Stack -> [ (
2 -> ) -> matching condition ( ), pop ( -> Stack -> [
3 -> } -> matching condition [ },  Stack -> [

Stack -> Not Empty =>  So brackets are not balanced.

({[ })]

{[1+(2*3)]/2}



Next greater element in same order as input
Given an array, print the Next Greater Element (NGE) for every element. The Next greater Element for an element x is the first greater element on the right side of x in array. Elements for which no greater element exist, consider next greater element as -1. The next greater elements should be printed in same order as input array.
Input : arr[] = [4, 3, 5, 2, 25, 10]
Output : 5 5 25 25 -1 -1

Current Element -> 10
Stack -> Empty
	Result :- 10 -> -1
	push(10) -> stack is empty()
Stack -> 10

Current Element -> 25 
Stack -> 10
	pop(10)  [10 <= 25], [stack.peek() <= arr[i]], stack.pop(), true
	Result :- 25 -> -1
	push(25) -> stack is empty()
Stack -> 25

Current Element -> 2  
Stack -> 25
	Result :- 2 -> 25
	push(2)  -> [25 <= 2], [stack.peek() <= arr[i]], false 
Stack -> 25, 2

Current Element -> 5  [2 <= 5], [stack.peek() <= arr[i]],  pop[2]
Stack -> 25, 2
	-> pop(2)
	Result :- 5 -> 25
	-> push(5) -> [25 <= 5], [stack.peek() <= arr[i]], false 
Stack -> 25, 5

Current Element -> 3  [5 <= 3], [stack.peek() <= arr[i]] 
Stack -> 25, 5
	Result :- 3 -> 5
	-> push(3)  -> [5 <= 3], [stack.peek() <= arr[i]], false 
Stack -> 25, 5, 3

Current Element -> 4  [5 <= 4], [stack.peek() <= arr[i]] 
Stack -> 25, 5, 3
	-> pop(3)	 -> [3 <= 4], [stack.peek() <= arr[i]], True 
	Result :- 4 -> 5
	-> push(4)	 -> [5 <= 4], [stack.peek() <= arr[i]], false 
Stack -> 25, 5, 4 

Result Array :-
10 -> -1
25 -> -1
2 -> 25
5 -> 25
3 -> 5
4 -> 5 
 
Assignment :- 
1. Convert an infix expression into a postfix expression
2. Convert infix expression to prefix expression  